# Day 4 | DDDによるビジネスロジックの構築: ユースケースから集約設計まで

昨日、私たちは抽象モデリングの4つの領域を完了し、概念、振る舞い、データ、アーキテクチャの4つの次元からシステムの本質を理解しました。しかし、これらの抽象的な理解を実行可能なビジネスロジックに変換しようとすると、重要な課題に直面します:

**ドメイン概念をどのように凝集性があり意味のあるビジネスユニットに組織化するか?**

これがDDD実践の核心的な問題です: **ユースケース分析から集約設計への体系的な変換**。今日は、ドメインモデルの静的構造を確立し、明日のユーザー操作シナリオの詳細な議論の基盤を築きます。

## ユースケース分析: 意図から境界の識別まで

### Day 2の6つのケースを再検討する

Day 2では、6つの典型的なユーザーケースを分析し、それぞれが**コアユースケースパターン**を持っていました。DDDの観点から再度分解してみましょう:

**投資取引システム [I-N-T-J] - 制御指向のユースケースパターン**

```
コアユースケース: リアルタイム取引決定の実行
主要アクター: プロフェッショナルトレーダー
コンテキスト内の目標: 可能な限り最短時間で高品質の取引を完了する
スコープ: 個人投資ポートフォリオ管理システム
レベル: ユーザーゴールレベル

主要成功シナリオ:
1. トレーダーが市場データを監視する
2. 取引機会を特定する
3. リスクインパクトを計算する
4. 取引注文を提出する
5. 取引実行を確認する
6. ポートフォリオステータスを更新する

拡張:
2a. 市場データが遅延している → システムが遅延警告を提供する
3a. リスクが制限を超える → システムが明示的な確認を要求する
4a. 資金不足 → システムが調整または融資を提案する
5a. 取引が失敗する → システムが再試行または手動処理状態に入る
```

このユースケース分析から、いくつかの**コアドメイン概念**を識別できます:

- **Trader** - 意思決定能力を持つ主体
- **Portfolio** - 資産配分の状態コンテナ
- **TradeOrder** - 取引意図の構造化された表現
- **MarketData** - 外部価格情報のソース
- **RiskAssessment** - 意思決定支援のための計算ロジック

**家族財務システム [E-N-T-J] - 調整指向のユースケースパターン**

```
コアユースケース: 協力的な家族支出の管理
主要アクター: 家族財務の責任者
コンテキスト内の目標: 家族メンバーの支出行動を調整し、予算バランスを維持する
スコープ: 家族財務管理システム
レベル: ビジネスサマリーレベル

主要成功シナリオ:
1. 家族予算と権限を設定する
2. 家族メンバーが支出を記録する
3. システムが予算状況をチェックする
4. 予算警告または調整をトリガーする
5. 家族財務レポートを生成する

役割相互作用の複雑さ:
- 主要意思決定者: ルールを設定し、全体を監視する
- 一般メンバー: 支出を行い、ルールに従う
- システム調整: ルール実行を確保し、透明性を提供する
```

ドメイン概念の識別:

- **Family** - 協力の境界とルールメーカー
- **FamilyMember** - 特定の権限を持つ参加者
- **Budget** - リソース配分のための制約ルール
- **Expense** - リソース消費の事実記録
- **PermissionManagement** - 協力的行動のための制御メカニズム

### ユースケースパターンのドメイン特性

6つのケースの比較分析を通じて、異なるユースケースパターンが異なる**ドメイン複雑性特性**に対応していることがわかりました:

| ユースケースパターン | 主要な複雑性 | コアチャレンジ | 設計フォーカス |
| --- | --- | --- | --- |
| 制御指向 (投資取引) | 時間感度 | ミリ秒レベルの決定 | 状態の一貫性 |
| 調整指向 (家族財務) | マルチロール協力 | 権限と透明性 | 役割境界 |
| 確実性指向 (健康監視) | データ信頼性 | 継続的監視 | データ整合性 |
| 適応型 (スマートホーム) | 柔軟な応答 | 段階的制御 | グレースフルデグラデーション |
| 透明型 (荷物追跡) | 情報同期 | マルチソースデータ統合 | 状態同期 |
| 創造型 (旅行共有) | 表現の柔軟性 | 創造的支援ツール | コンテンツの流動性 |

各パターンは集約設計戦略に影響を与えます。

## 集約の識別: ビジネス境界を分割する技術

### 集約識別の3つの原則

**原則1: ビジネス不変条件の境界**
集約の境界は、ビジネスにおいて一貫性を保つ必要がある概念のセットに対応する必要があります。

**投資取引システムの不変条件分析**:

```
Portfolioアグリゲートの不変条件:
- 総資産価値 = Σ(保有価値) + 現金残高
- いかなる取引も現金残高をマイナスにすることはできない
- リスクエクスポージャーは事前設定された制限を超えることはできない

Orderアグリゲートの不変条件:
- 注文のコアパラメータは提出後に変更できない
- 実行記録は元の指示に対応する必要がある
- 状態遷移はビジネスプロセスに準拠する必要がある
```

**原則2: トランザクション境界の対応**
集約内の変更は単一のトランザクションで完了できる必要があります。

**家族財務システムのトランザクション分析**:

```
Familyアグリゲート:
✓ 単一トランザクションで完了可能:
  - 予算額を設定する
  - メンバー権限を調整する
  - 基本的な家族情報を更新する

✗ 単一トランザクションで完了不可能:
  - 全メンバーの月間支出を集計する (複数の集約にまたがる)
  - 年次レポートを生成する (データ量が大きすぎる)
```

**原則3: ビジネス言語の対応**
集約の命名と構造は、ビジネス専門家の言語に直接対応する必要があります。

### 6つのケースの集約設計比較

**ケース1: 投資取引システム**

```
集約設計:
┌─────────────────┐    ┌─────────────────┐
│   Portfolio     │    │      Order      │
│  (投資ポートフォリオ)     │    │    (取引注文)   │
├─────────────────┤    ├─────────────────┤
│ - portfolioId   │    │ - orderId       │
│ - traderId      │    │ - portfolioId   │
│ - holdings[]    │    │ - tradeOrder    │
│ - cashBalance   │    │ - status        │
│ - riskLimit     │    │ - execution[]   │
└─────────────────┘    └─────────────────┘
        │                       │
        └───────────────────────┘
             ドメインイベント通信

設計ロジック:
- Portfolioは資産状態とリスク制御を管理する
- Orderは取引プロセスと実行追跡を管理する
- 両者はイベントを通じて結果整合性を維持する
```

**ケース2: 家族財務システム**

```
集約設計:
┌─────────────────┐    ┌─────────────────┐
│     Family      │    │     Budget      │
│    (家族)       │    │    (予算)       │
├─────────────────┤    ├─────────────────┤
│ - familyId      │    │ - budgetId      │
│ - members[]     │    │ - familyId      │
│ - permissions   │    │ - categories[]  │
│ - settings      │    │ - limits        │
└─────────────────┘    │ - period        │
                       └─────────────────┘
              │                 │
              └─────────────────┘
                イベント駆動調整

┌─────────────────┐
│    Expense      │
│   (支出記録)    │
├─────────────────┤
│ - expenseId     │
│ - familyId      │
│ - memberId      │
│ - amount        │
│ - category      │
│ - timestamp     │
└─────────────────┘

設計ロジック:
- Familyはメンバーと権限構造を管理する
- Budgetは予算ルールと制限を管理する
- Expenseは実際の支出事実を記録する
- 3つが協力して予算制御を達成する
```

**ケース3: 健康監視システム**

```
集約設計:
┌─────────────────┐    ┌─────────────────┐
│   HealthProfile │    │  DeviceReading  │
│   (健康プロファイル)    │    │   (デバイスデータ)    │
├─────────────────┤    ├─────────────────┤
│ - userId        │    │ - readingId     │
│ - metrics[]     │    │ - userId        │
│ - thresholds    │    │ - deviceType    │
│ - history       │    │ - value         │
└─────────────────┘    │ - timestamp     │
                       │ - status        │
                       └─────────────────┘

設計ロジック:
- HealthProfileは長期的な健康状態を管理する
- DeviceReadingはリアルタイムデータ収集を管理する
- 分離設計は異なるデータライフサイクルをサポートする
```

### 集約間の相互作用パターン

異なるドメインは異なる集約相互作用パターンを生み出します:

**パターン1: イベント駆動調整 (投資取引)**

```
Portfolioアグリゲート → TradeValidatedEvent → Orderアグリゲート
Orderアグリゲート → OrderExecutedEvent → Portfolioアグリゲート
Portfolioアグリゲート → PortfolioUpdatedEvent → RiskManagementアグリゲート
```

**パターン2: 権限駆動協力 (家族財務)**

```
Familyアグリゲート → 権限ルールを設定 → Expenseアグリゲートが権限をチェック
Budgetアグリゲート → 制限ルールを設定 → Expenseアグリゲートが制限をチェック
Expenseアグリゲート → 支出を記録 → Budgetアグリゲートがステータスを更新
```

**パターン3: データ駆動集約 (健康監視)**

```
デバイス → データをプッシュ → DeviceReadingアグリゲート
DeviceReadingアグリゲート → データ検証完了 → HealthProfileアグリゲート
HealthProfileアグリゲート → 閾値チェック → Alertアグリゲート
```

## ドメインサービス: 集約を超えるビジネスロジック

### ドメインサービスをいつ識別するか

ビジネスロジックが**単一の集約に自然に属さない**場合、ドメインサービスが必要です。

**投資取引システムのドメインサービスケース**:

```typescript
// リスク計算サービス: PortfolioとMarketDataの協力が必要
class RiskCalculationService {
  calculate(portfolio: Portfolio, marketData: MarketData): RiskMetric {
    // このロジックはPortfolioに属さない (外部市場データが必要なため)
    // MarketDataにも属さない (ポートフォリオ固有の情報が必要なため)

    const portfolioValue = portfolio.getTotalValue(marketData);
    const volatility = marketData.calculateVolatility(portfolio.getSymbols());
    const concentration = portfolio.calculateConcentration();

    return new RiskMetric(portfolioValue, volatility, concentration);
  }
}

// 取引実行調整サービス: PortfolioとOrderアグリゲートを調整する
class TradeExecutionService {
  async executeTrade(
    portfolio: Portfolio,
    tradeOrder: TradeOrder
  ): Promise<ExecutionResult> {
    // 1. Portfolioの取引能力を検証する
    const validation = portfolio.validateTrade(tradeOrder);
    if (!validation.isValid) {
      return ExecutionResult.rejected(validation.reason);
    }

    // 2. Orderアグリゲートを作成して実行プロセスを管理する
    const order = Order.create(portfolio.getId(), tradeOrder);

    // 3. 市場に提出する (外部サービス)
    const marketResult = await this.marketService.submit(order);

    // 4. 関連集約のステータスを更新する
    if (marketResult.isSuccessful) {
      portfolio.applyExecution(marketResult);
      order.markAsExecuted(marketResult);
    }

    return ExecutionResult.fromMarket(marketResult);
  }
}
```

### ドメインサービスの設計原則

**ステートレス性**: ドメインサービス自体は状態を保持せず、集約間の相互作用を調整するだけです

**ビジネス指向**: サービスの命名とインターフェースは、技術実装ではなくビジネス概念を反映する必要があります

**最小責任**: 各サービスは明確なビジネスシナリオのみを処理します

## ユーザー操作シナリオの準備

### ドメインモデルからユーザーロールへ

今日確立した集約設計は、明日どのようにユーザー操作シナリオを設計するかに直接影響します:

**ロールと集約の対応**:

```
投資取引システム:
- トレーダーロール → Portfolioアグリゲートの所有者
- システム管理者 → システム全体の監視者
- リスク管理専門家 → RiskManagementアグリゲートのオペレーター

家族財務システム:
- 家族の長 → Familyアグリゲートのマネージャー
- 家族メンバー → Expenseアグリゲートの作成者
- 予算マネージャー → Budgetアグリゲートのメンテナー
```

**操作権限の集約境界**:

- 各集約は特定のロールの操作境界を定義する
- 集約を超える操作はドメインサービスを通じて調整する必要がある
- 複雑なビジネスプロセスはマルチステップユーザーストーリーを生み出す

### 状態シナリオの準備

各集約の状態変化は対応するユーザー操作シナリオを生み出します:

**Portfolioアグリゲートの状態遷移**:

```
空のポートフォリオ → [資金を初期化] → アクティブポートフォリオ
アクティブポートフォリオ → [取引を実行] → アクティブポートフォリオ (ステータス更新)
アクティブポートフォリオ → [リスク超過] → 制限付きポートフォリオ
制限付きポートフォリオ → [リスク調整] → アクティブポートフォリオ
アクティブポートフォリオ → [全て売却] → 空のポートフォリオ
```

各状態遷移はユーザー操作シナリオに対応します。明日、これらの遷移を直感的なユーザーストーリーに設計する方法を深く掘り下げます。

## 設計決定の記録

集約を設計する際、多くの重要な決定を行いました。これらの決定を記録することは、後続のユーザーストーリー設計にとって重要です:

**決定1: PortfolioとOrderを分離する**

- 理由: Portfolioは資産状態に焦点を当て、Orderは取引プロセスに焦点を当てる
- 影響: ユーザーは異なるインターフェースで資産状態と取引状態を表示する必要がある
- ユーザーストーリーへの影響: 集約を超える操作フローを設計する必要がある

**決定2: Familyアグリゲートに権限管理を含める**

- 理由: 権限設定は家族構造と密接に関連している
- 影響: 権限変更はFamilyアグリゲートの状態変化をトリガーする
- ユーザーストーリーへの影響: 権限管理のユーザーインターフェースを設計する必要がある

**決定3: 健康データに読み取り/書き込み分離を採用する**

- 理由: 読み取りと書き込みの頻度が大きく異なる
- 影響: リアルタイムクエリと履歴分析は異なるデータソースを使用する
- ユーザーストーリーへの影響: データ同期の時間遅延を考慮する必要がある

## 明日への橋渡し

今日の集約設計を通じて、ビジネスロジックの静的構造を確立しました。明日は以下を深く掘り下げます:

1. **ユーザーストーリー作成テクニック**: 集約のビジネス能力をユーザーストーリーに変換する方法
2. **ロールと権限設計**: 集約境界に基づいてロールと権限システムを設計する方法
3. **操作シナリオフロー**: 集約を超える複雑なビジネスフローを設計する方法
4. **状態シナリオ管理**: 集約状態変化がもたらすユーザーエクスペリエンスの課題を処理する方法

## 今日の概念的要点

- **集約はビジネス不変条件の境界である**: 技術実装はビジネスルールに奉仕する必要がある
- **ドメインサービスは集約を超えるロジックを調整する**: 複雑なビジネスプロセスの組織化
- **異なるドメインには異なる集約パターンがある**: 投資、家族、健康はそれぞれ独自の特性を持つ
- **集約設計はユーザーエクスペリエンスに直接影響する**: 優れたドメインモデルは優れたUXの基盤である

覚えておいてください: 今日確立したのは技術アーキテクチャではなく、ビジネスロジックの組織化です。この組織化は、明日ユーザーの操作エクスペリエンスをどのように設計するかを直接決定します。

---

> 「集約はコードのグループ化ではなく、ビジネス概念の生きた単位です。各集約には独自のユニークなライフサイクルがあり、すべてのユーザー操作はこのライフサイクルの進化に参加しています。」
