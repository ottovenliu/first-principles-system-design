# Day 16 | Dev / Staging / Prod マルチ環境ガバナンスとアーキテクチャ戦略: AWSマルチ環境設定管理とデプロイメント戦略

これまでの2つのトピック、<Infrastructure as Code: Terraformでインフラストラクチャをコード化しバージョン管理する>と<完全なCI/CD自動化実装 - GitHub Actions × CodePipeline × CodeBuild>で、**「インフラストラクチャを予測可能、反復可能、バージョン管理可能にすること」**の重要性と、**「既存のビジネスロジックがコード変更によって破壊されるのをアクティブに保護すること」**について、それぞれ議論しました。両方とも`テストとデプロイメントのための安定した環境と固定されたビジネスロジック検証プロセスを持たない`という問題を解決することを目的としており、私たちの**`ビジネスロジック検証`**が安定した土壌の中でそびえ立つ木のように力強く成長できることを保証します(台湾の某銀行の話ではありません)。環境の重要性と対応する痛点への解決策について簡単に話した後、今回は議論します - **`どのような環境が必要なのか?`**

最近、友人とリージェント台北のImpromptu by Paul Leeというレストランを訪れ、2025年夏の味を楽しむ機会がありました。オープンキッチンと客席エリアを組み合わせたユニークなデザインで、シェフとそのチームが食材、スパイス、厳選されたワインを使って2025年夏の美しく壮大なタペストリーをどのように提示するかをシンプルかつ透明に見ることができました。私はこのメニューデザインが大好きでした。明確で、鮮明で、率直なエレガンスを感じることができました。

しかし話は変わりますが、ミシュランスターの料理はどのようにデザインされるのでしょうか？新しいコンセプトはすべてのグルメにとってエキサイティングなニュースですが、もしカウンターで作ってお客様に直接提供し、それが失敗したらどうなるでしょうか？塩が多すぎたり、調理時間が間違っていたり - 良くても評判を失い、最悪の場合、お客様が腹痛を起こし、翌日にはあなたのレストランの名前が見出しで台無しになります。

では一歩下がって考えましょう。公式リリース前に、レストランの「メインキッチン」バックステージの片隅で試作してみるのはどうでしょうか？

これは良い方法です。お客様が実験的な料理をすぐに味わうことを避けられます。しかし、お客様には見えませんが、既存のキッチンの正常な運営を妨害する可能性があります。調理準備に使用されているまな板を占領したり、必要なときにソースが別のシェフによって使い切られていることに気づいたり、または私たちの実験からの煙が隣の慎重に調理された料理に影響を与える可能性すらあります。

つまり、資金とスペースが許すなら、完全に独立した「テストキッチン」で私たちの新しいコンセプトを実現しようとするのが最適な解決策のようです。ここでは、私たち自身の完全な鍋、フライパン、食材、オーブンのセットがあり、外部のレストラン運営に影響を与える心配なく、自由に実験、失敗、再試行できます。

これが**開発環境(Dev)**です。完全に分離されたサンドボックスであり、すべての開発者が何かを「壊す」ことや誰かに影響を与えることを心配せずに、自由に自分のコードを書き、修正し、テストできます。**「メインキッチン」バックステージ(共有環境)**で他の機能をテストしている同僚に影響を与えることを防ぎ、その逆も同様です。最も重要なことは、本番環境(Production / Prod)で直接コードを書くことを最大限避けることです。不正なデータベースコマンドのような小さなミスでも、すべてのユーザーのサービス中断やデータ損失につながる可能性があります。**`これは絶対に、絶対に禁止された行為です。`**

正式に提供される前に、私たち自身の**R&Dキッチン(開発環境)**で新しい料理を作り、それは天国の味がします。次は何でしょうか？直接メニューに載せて、最も重要な食評論家に販売しますか？

シェフの帽子の上にマスターシェフが隠れていなくて、私たちが提供しているのがラタトゥイユである場合(Ratatouilleは素晴らしい映画です、時間があれば見てください)、これは非常に危険な動きです。

正式なローンチの前に、**「最終リハーサル」**のための場所が必要です。この場所を「ステージングキッチン」と呼びます。その設定、ストーブ、ワークフロー、さらには皿のブランドまで、正式な「メインキッチン」と同一でなければなりません。ここで、実際の提供プロセスをシミュレートする必要があります：ウェイターは注文から提供までの全プロセスを通さなければならず、シェフチームはピーク時のプレッシャーの下で意図されたプロセスに従って料理を安定して作れるかシミュレートし、最後にこの新しい料理が他のクラシック料理と一緒に提供されたときにプロセスと競合しないかテストする必要があります。

これが**Staging / プリプロダクション環境**の重要性です。私たちは、ビジネスロジックが要件と品質基準を満たしていることを確認するために、さまざまなシナリオで包括的にテストするための環境を持たなければなりません。

今、ソフトウェア開発ライフサイクルを明確な「進行」に抽象化できます：

```python
Dev => Staging => Prod
```

- **開発環境(Dev): テストキッチン**
  - **目的**: 機能開発、ユニットテスト、迅速な反復。
  - **特性**: 混沌は常態です。頻繁な変更、デプロイメント、完全な解体さえ許可されます。開発者はより高い権限を持ちます。データは通常、偽物または匿名化されています。
  - **コアフォーカス**: 開発効率。

- **Staging環境: ステージングキッチン**
  - **目的**: 統合テスト、ユーザー受け入れテスト(UAT)、パフォーマンスストレステスト。すべての実際のシナリオをシミュレート。
  - **特性**: 環境は本番環境に極めて近くなければなりません。設定、OS、ネットワークルール、データベースバージョンなどは一貫している必要があります。デプロイメントプロセスも正式なローンチプロセスと同一である必要があります。データは本番環境のレプリカ(脱感作後)である可能性があります。
  - **コアフォーカス**: 安定性と一貫性。これが本番前の品質の最後の防衛線です。

- **本番環境(Prod): ミシュランスターレストラン**
  - **目的**: 実際のユーザーにサービスを提供し、価値を創造。
  - **特性**: 極めて安定、安全、高性能。いかなる変更も厳格な承認と標準化されたプロセスを経る必要があります。アクセス制御が最も厳格で、通常、自動化ツールまたは非常に限られた数の承認された担当者のみがデプロイメントを実行できます。
  - **コアフォーカス**: 信頼性とセキュリティ。

この**`Dev => Staging => Prod`**の一方向フローは、ソフトウェア品質保証の`コアワークフロー`です。コードは水のように、下位環境から上位環境にのみ流れることができ、決して逆流してはいけません。各フローは**`「品質ゲート」`**でのチェックであり、**CI(継続的インテグレーション)**プロセスでの**`自動チェック`**によって**`既存のビジネスロジックがコード変更によって破壊されるのを保護する`**か、<バージョン管理戦略(PRレビュー戦略)>で述べられた**Peer Review Gate**、**Business Review Gate**、**Quality Review Gate**の3方向検証かにかかわらず。**`ビジネスロジックの実装条件が満たされていない`**場合は、直ちに緊急修理のために返却する必要があります。私たちは深く明確に理解しなければなりません - **`システムは抽象的なビジネスロジックの実装である`**。

現代のソフトウェア開発において、マルチ環境管理はアプリケーションの安定性と信頼性を確保する鍵です。次に、AWS上でDev/Staging/Prodマルチ環境アーキテクチャを構築し管理する方法を深く掘り下げ、Dockerコンテナ化、ECSクラスタ管理、EKS/K8sオーケストレーションなどの核心技術に焦点を当てます。

> 1. マルチ環境アーキテクチャ設計原則 - 環境分離戦略とIaC実践
> 2. Dockerコンテナ化戦略 - マルチステージビルドと環境別設定
> 3. Amazon ECSクラスタ管理 - サービス定義とオートスケーリング設定
> 4. Amazon EKSとKubernetes管理 - クラスタ設定、アプリケーションデプロイ、Ingressセットアップ
> 5. CI/CDパイプライン統合 - GitHub Actionsワークフローとブルー/グリーンデプロイメント
> 6. 設定管理とシークレット管理 - AWS Secrets ManagerとK8s ConfigMap/Secret
> 7. 監視とログ管理 - CloudWatchとPrometheus/Grafana統合
> 8. セキュリティベストプラクティス - ネットワークセキュリティとRBAC設定
> 9. コスト最適化戦略 - 自動化されたリソース管理とスポットインスタンス統合
> 10. 災害復旧とバックアップ - リージョン間バックアップとデータベースフェイルオーバー

## 1. マルチ環境アーキテクチャ設計原則

### 1.1 環境分離戦略

私たちは上記で、レストラン(私たちのシステム)を「R&Dキッチン(Dev)」、「ステージングキッチン」、「フラッグシップストア(Prod)」に分ける必要があることを議論しました。実際にどのように「境界を定める」か、そしてこれら3つの土地の「建築基準」が一貫していることを確保する方法について話しましょう。

```python
本番環境
├── 高可用性設定
├── オートスケーリング
├── 完全な監視とアラート
└── 厳格なデプロイメントプロセス

Staging環境
├── 本番環境のミラー
├── 完全な機能テスト
├── パフォーマンステスト環境
└── 統合テスト検証

開発環境
├── 迅速なデプロイメント
├── 開発者フレンドリー
├── リソースコスト最適化
└── 柔軟な設定調整
```

最もシンプルな方法は、もちろん各キッチンをロックし、対応する機能的ニーズを持つ人々に専用の鍵を渡すことです。まずドアをロックして、人々が歩き回るのを防ぎます。私たち自身の人々がうっかりパラメータを調整したり、サービス麻痺を引き起こす設定エラーを起こすだけでも十分悪いです。少なくとも、鍵を持たない泥棒や強盗が入ることさえできないことを確保しなければなりません。したがって、私たちの最初のコア原則はシンプルです：**`爆発半径を最小化する`**。これは、1つの環境で災害が発生した場合(例：ハッキングされた、または設定エラーによるサービス麻痺)、他の環境に絶対に影響を与えてはいけないことを意味します。

AWSで、この目標を達成するためのゴールドスタンダードは**`マルチアカウント戦略`**と呼ばれます。

**1. AWS Organizations: クラウド企業本社**

**`AWS Organizations`**は私たちの「企業本社」であり、これを通じて異なるAWSアカウントを管理し、基本的なポリシーを策定できます。グループが財務、営業、法務、HR、開発、保守のための異なる事業部門を持っているように、`DevOU`と`ProdOU`を事業部門の概念として作成できます。`Account-Dev`(部門)は`DevOU`(事業部門)に配置され、`Account-Staging`と`Account-Prod`は`ProdOU`に配置されます。次に、**`サービスコントロールポリシー(SCP)`**を設定して、その下のアカウントが**できること**または**できないこと**を制限できます。これはグループによって発行された「最高執行命令」のようなものです。事業部門ポリシーとグループ本社の間に矛盾がある場合、`SCP`の規制が優先的かつ強制的に従われます。そして`AWS Organizations`にはもう1つの利点があります：事業部門のすべての請求書とコストが本社で集約され、監視と管理が便利です。

`SCP`は人的エラーや悪意のある行動を根本から防ぎ、事後に修正するよりもはるかに効果的です。各環境の「行動憲法」と「物理法則」を定義します。例えば：

- DevOU下のすべてのアカウントに対して:
  - 外部ネットワークに接続されたデータベースの作成を禁止(RDS public access = false)。
  - CloudTrail(監査ログ)の無効化を禁止し、すべての操作が記録されることを保証。
  - リソース作成をアジア太平洋地域(例：東京、シンガポール)に制限し、誤って高価なヨーロッパやアメリカ地域にリソースを作成することを防ぐ。
- ProdOU下のすべてのアカウントに対して:
  - 特定の管理者ロールを除き、データベースやS3バケットの削除を禁止。

**2. IAM権限: 異なるアイデンティティのための「パス」**

アカウント分離後、人々はどのように仕事をするために入るのでしょうか？答えはIAM Rolesであり、各アカウントでユーザー名とパスワード(IAM User)のセットを作成することではありません。

- **概念**: Management AccountにIAM Usersを作成し、次に異なるIAM Roles(例：DeveloperRole、QARole、OperatorRole)を定義します。次に、これらのUsersに他のアカウントでタスクを実行するために「Assume Role」させます。
- **たとえ話**: 私たちは会社の従業員(IAM User)であり、会社は私たちに異なる作業バッジ(IAM Role)を与えます。
  - 「開発者バッジ」があれば、Account-Devのすべての部屋にスワイプで入れます。
  - 「QAバッジ」があれば、Account-Stagingに入れますが、観察と記録のみで、機器を変更できません。
  - 「フラッグシップストアマネージャーバッジ」を持つ者だけが、承認後にAccount-Prodに入って操作できます。

このアプローチは権限管理を一元化し、安全で明確にします。

### 1.2 Infrastructure as Code (IaC)

環境間に強固な壁があることを確保しましたが、「ステージングキッチン」と「フラッグシップストア」の内装、配管、ストーブが同一であることをどのように保証しますか？これが`Infrastructure as Code (IaC)`の力が発揮される場所です。`青写真(IaC)`に従って、同一のアーキテクチャと環境を迅速に構築できます。<Infrastructure as Code: Terraformでインフラストラクチャをコード化しバージョン管理する>で青写真の重要性について述べました。それはインフラストラクチャを`予測可能`、`反復可能`、`進化可能`にします。Terraformを例に続けましょう。

```
terraform/
├── modules/
│   ├── vpc/
│   │   ├── main.tf
│   │   └── variables.tf
│   └── ec2_instance/
│       ├── main.tf
│       └── variables.tf
│
└── environments/
    ├── dev/
    │   ├── main.tf
    │   └── terraform.tfvars
    ├── staging/
    │   ├── main.tf
    │   └── terraform.tfvars
    └── prod/
        ├── main.tf
        └── terraform.tfvars
```

- `modules/`は標準化された建築モジュールを保存します。
- `environments/`は各環境の「建設指示」を保存します。

`environments/dev/main.tf`では、偽のコードで提示します：

```yaml
# VPCモジュールを参照
module "my_vpc" {
  source = "../../modules/vpc"
  cidr_block = var.vpc_cidr
}

# EC2モジュールを参照
module "web_server" {
  source      = "../../modules/ec2_instance"
  instance_type = var.instance_type
  vpc_id      = module.my_vpc.id
}
```

気づきましたか？この`main.tf`ファイルは、dev、staging、prodでほぼ同じに見えます。実際の違いは、その隣にある`terraform.tfvars`パラメータファイルにあります：

- `environments/dev/terraform.tfvars`
```
vpc_cidr      = "10.10.0.0/16"
instance_type = "t3.micro"  // dev環境で小型マシンを使用してコスト削減
```

- `environments/prod/terraform.tfvars`
```
vpc_cidr      = "10.20.0.0/16"
instance_type = "m5.large"  // 本番環境で大型マシンを使用してトラフィックを処理
```

Dev環境をデプロイしたいとき、`environments/dev`フォルダに入って`terraform apply`を実行するだけです。Terraformは自動的に`dev`パラメータを読み取り、共有モジュールに適用し、開発仕様を満たす環境を構築します。`Prod`のデプロイも同様です。

これは私たちのIaC目標を完璧に達成します：
1. **一貫性**: すべての環境の「アーキテクチャ」は同じ青写真(modules)から来ます。
2. **追跡可能性**: すべてのインフラストラクチャ変更はコードを変更することによって行われなければなりません。すべての変更はバージョン管理システム(Gitなど)に記録され、レビューと追跡が可能です。
3. **再現性**: 環境全体が破壊されても、同じコードで同一のものを迅速に再構築できます。

## 2. Dockerコンテナ化戦略

IaCを使用して3つのキッチンのアーキテクチャ青写真を既に描きました。今、私たちの「調理ツール」を標準化する必要があります。これがDockerコンテナ化戦略が解決しようとしている問題です。

私たちは皆、このクラシックなシナリオを聞いたことがあり、おそらく経験したことさえあります：
> 開発者A: 「この機能は私のマシンで正常に動作します！なぜデプロイメント後に壊れたのですか？」

この「私のマシンでは動作する」問題は、Dockerが治そうとしている慢性疾患です。問題の根本は、開発者のコンピュータ、テストサーバー、本番サーバーの「環境」に微妙だが致命的な違いがあることです：
- 異なるOSバージョン(Ubuntu 20.04 vs 22.04)
- 依存ライブラリの異なるバージョン(Python 3.8 vs 3.9、OpenSSL v1 vs v3)
- 異なる環境変数設定
- 異なるハードウェアパラメータ
- 異なるシステムパスやファイル権限

すべてが同じでも、1つはテストに合格し、もう1つは失敗する可能性があります。Windows(偏見はありませんが、ここが`根本的な違い`が最も発生しやすい場所です)のような同じOSでも、お供え、聖水、またはオムニシアを賞賛して機械の精霊がスムーズに実行するよう祈るしかありません。

**`Docker`**の核心的なアイデアは、アプリケーションを「実行環境全体」と一緒にパッケージ化して持ち運ぶことです。

シェフに「ブッフ・ブルギニョン」のレシピを渡して、自分のキッチンの鍋、ストーブ、調味料を使わせる(各キッチンの違いにより味が異なる可能性が高い)代わりに、半完成品、特別なソース、精密な温度制御を備えた「標準化された加熱ボックス」を渡した方がよいでしょう。彼がすることは、ボタンを押すだけです。

この「標準化された加熱ボックス」が**Dockerコンテナ**です。このボックスには以下が含まれます：
1. 私たちのアプリケーションコード(料理そのもの)
2. ランタイム、例：Node.js v18またはJava 17(特定の調理ソース)
3. すべてのシステムレベルのライブラリとツール(特別な塩と胡椒)

この「ボックス」を`Dev`環境の電子レンジや`Prod`環境の最高級オーブン(両方とも資格のあるDocker Hostsである限り)に入れても、加熱後に出てくる料理は全く同じ味であることが保証されます。これがコンテナ化がもたらす`ポータビリティ`と`一貫性`です。

### 2.1 マルチステージビルド最適化

Dockerfileビルドプロセスを2つのステージに分割します。組立ラインのようなものです：
- **ステージ1(ビルダーステージ):** 広々として設備の整った「処理工場」。
- **ステージ2(最終ステージ):** クリーンで軽量な「配送ボックス」。

```dockerfile
# Dockerfile.multi-stage
# ビルドステージ
FROM node:18-alpine AS builder
WORKDIR /app
# ビルドに必要なpackage.jsonのみをコピー
COPY package*.json ./
# 本番に必要な依存関係のみをインストール
RUN npm ci --only=production

# 開発ステージ
FROM builder AS development
RUN npm ci
COPY . .
EXPOSE 3000
CMD ["npm", "run", "dev"]

# 本番ステージ
FROM node:18-alpine AS production
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .
EXPOSE 3000
USER node
CMD ["npm", "start"]
```

これを行う利点は明らかです：
- **非常に小さな最終イメージ:** `node_modules`(本番)、`dist`、`package.json`のみが含まれます。ソースコードも開発ツールもありません。
- **より高いセキュリティ:** 攻撃面が最小化されます。パッケージが攻撃されたり、トロイの木馬が埋め込まれたりするニュースは一般的ではありませんが、聞いたことがあります。コンパイルツール(gccやnpmなど)や開発ライブラリは、ハッカーの脆弱性になる可能性があります。したがって、本番環境には`「最低限必要な」`実行コンポーネントのみが含まれるべきです。
- **明確なビルドプロセス:** 「どのようにビルドするか」と「どのように実行するか」の関心事を分離します。

### 2.2 環境別設定管理

1つのボックスを異なるキッチンにどのように適応させますか？

標準化された「加熱ボックス」は既にありますが、今新しい問題があります：
> Dev環境では、この料理は`dev-database`に接続する必要があります。Prod環境では、`prod-database`に接続する必要があります。
> 
> しかし、私たちは1つのボックス(Docker Image)しかないので、どうすればいいですか？

```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  app:
    build:
      context: .
      target: development
    environment:
      - NODE_ENV=development
      - LOG_LEVEL=debug
    volumes:
      - .:/app
      - /app/node_modules
    ports:
      - "3000:3000"

# docker-compose.prod.yml
version: '3.8'
services:
  app:
    build:
      context: .
      target: production
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=error
    restart: unless-stopped
    ports:
      - "80:3000"
```

まず、鉄の掟、絶対的なルールを守ることを覚えておく必要があります：
> #### **一度ビルドし、どこでも実行**

異なる環境のニーズのために、封印されたお弁当箱を開けてはいけません。これは**`イメージの不変性`**を完全に違反します。異なる環境用に異なる`Images`をビルドしてはいけません(例：`my-app:dev`、`my-app:prod`)。これは、私たちが確立したすべての**`一貫性保証`**を破壊します。

```
Devでテストに合格したImageは、StagingとProdにデプロイされる全く同じ、変更されていないImageでなければなりません。
```

しかし、`外部注入`のニーズが本当にある場合はどうすればよいでしょうか？

したがって、私たちの「標準加熱ボックス」にはいくつかのスロットが予約されています。「データベース接続スロット」や「APIキースロット」のようなものです。ボックス自体はこれらのものを運びません。代わりに、特定のキッチンの指定された場所に置かれたとき、キッチンの「自動アーム」(コンテナオーケストレーションシステム)が対応するプラグを差し込みます。

または、一部の日本のインスタントラーメンのように、お湯の入口と水の出口は異なる穴であり、それぞれ独自の目的があります。私たちはお湯、熱いお茶(これも良い、試しました)、またはホットミルクティー(???、見たことがありますが尊重します)を注ぎ、排水できますが、中のメインボディ(麺と調味料)は変わりません。

YAMLの例を振り返ると、いくつかの手がかりが見つかります：

```yaml
# docker-compose.dev.yml
    environment:
      - NODE_ENV=development
      - LOG_LEVEL=debug

# docker-compose.prod.yml
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=error
```

**`環境変数`**を宣言することで、異なるインターフェースを設定できます。これは最も標準的な方法であり、12-Factor Appの哲学に最も適合します - **アプリケーションコードは設定をハードコードせず、環境変数から読み取る必要があります**。

コンテナが起動するとき(ECS/Kubernetesによって管理される)、次のように実行します：
- Dev環境で: `docker run -e DATABASE_HOST=dev.db.internal ... my-app`
- Prod環境で: `docker run -e DATABASE_HOST=prod.db.internal ... my-app`

より複雑な設定(例：完全な`settings.json`)の場合、コンテナオーケストレーションシステムは、起動時に対応する環境の設定ファイルをコンテナ内の特定のパス(例：`/etc/config/settings.json`)に「マウント」できます。私たちのアプリケーションは、この固定パスからファイルを読み取るだけです。

最後に、より高度で安全な方法があります：**`起動時に設定サービスから取得する`**。コンテナが起動すると、アプリケーションは割り当てられたアイデンティティ(例：AWS ECS Task Role)を使用して、外部サービス(AWS Secrets ManagerやParameter Storeなど)を呼び出し、必要なデータベースパスワード、APIキーなどを取得します。こうすることで、環境変数にも平文で表示されず、最高レベルのセキュリティです。

## 3. Amazon ECSクラスタ管理

標準化されたキッチン(IaC)を既に構築し、標準化された「半完成食事キット」(Docker Images)を設計しました。今、バックエンド全体の運営を管理するための知的で効率的な「ヘッドシェフシステム」が必要です。このシステムは以下を知る必要があります：
- 料理(私たちのアプリケーション)の標準調理手順は何ですか？
- ピーク時(高トラフィック)にこの料理を作るために、何台のストーブを同時に動作させるべきですか？
- ストーブが故障した場合(サーバー障害)、調理を続けるために自動的に新しいものと交換する方法は？

この「ヘッドシェフシステム」が**`Amazon ECS (Elastic Container Service)`**です。

### 3.1 ECSサービス定義

ECSを理解するために、まずその4つのコアコンポーネントを知る必要があります：`ECSクラスタ - 「キッチン自体」`、`タスク定義 - 「標準作業手順(SOP)カード」`、`タスク - 「強火ストーブ上の中華鍋」`、`サービス - 「疲れ知らずのヘッドシェフ」`。

1. **ECSクラスタ - 「キッチン自体」**
- **コア概念:** すべてのコンテナ化されたアプリケーションを含むために使用される論理的なグループ化。`Dev Kitchen Worktop`、`Staging Kitchen Worktop`、`Prod Kitchen Worktop`と考えることができます。何平方フィートのキッチン作業エリアがあるかを人々に伝えるようなもので、内部の実際のレイアウトには触れません。それ自体はコストがかからず、単なる管理境界です。
- **重要なポイント:** クラスタが動作するには「計算能力」が必要です。キッチンにはストーブが必要なのと同じです。計算能力のソースには2つのモードがあります：
  - **EC2モード:** 私たち自身でバッチの「ストーブ」(EC2クラウドサーバー)を購入し、キッチンに登録します。ストーブのブランドとモデルを完全に制御でき、自由に調整できますが、メンテナンスと管理にも責任があります。
  - **Fargateモード(サーバーレス - 業界の主流トレンド):** ストーブを購入しません。調理が必要なときに、AWSに伝えるだけです：「500Wの電力と1平方メートルのエリアを持つストーブが必要です。」AWSは自動的に、その広大なリソースプールから要件を満たすストーブを出現させ、終わったら消えます。
  - 大多数の新しいアプリケーションにとって、Fargateが優先選択です。面倒なサーバー管理から解放され、アプリケーション自体により集中できます。

2. **タスク定義 - 「標準作業手順(SOP)カード」**
- **概念:** これはECSのコアブループリントです。「料理の作り方」を詳細に定義するJSON形式の取扱説明書です。
- **重要なポイント:** シェフのための完全なSOPカードのようなもので、正確に記載されています：
  - `image:` どのバージョンの「半完成食事キット」を使用するか(Docker Image URL)。
  - `cpu & memory:` このタスクにどれだけの「火力」と「スペース」を割り当てるか。
  - `environment:` どのような「調味料」を注入するか(環境変数、例：DATABASE_URL)。
  - `secrets:` 「金庫」(AWS Secrets Manager)からどの「秘密のレシピ」を取得するか(APIキー、データベースパスワード)。
  - `logConfiguration:` 調理プロセスの記録(ログ)をどこに送信するか(例：CloudWatch Logsへ)。
  - `taskRoleArn:` このシェフにどのような「権限カード」(IAM Role)を与えるか、他のAWSサービスとのやり取りを許可する(例：S3からファイルを読む)。

3. **タスク - 「強火ストーブ上の中華鍋」**
- **概念:** タスク定義の「実行インスタンス」。ECSが実際にSOPカードに基づいてコンテナを起動すると、その実行中のコンテナがTaskです。Tasksの数を設定することで、同時にいくつの中華鍋が炒めているかを決定できます。

4. **サービス - 「疲れ知らずのヘッドシェフ」**
- **概念:** ServiceはECSの頭脳と執事です。その義務は、私たちが望む状態を維持することです。
- **重要なポイント:** キッチンのすべてが私たちが望む実行順序に従って動作することを確保します。
  - `desiredCount: { N }`: 「常に`{ N }`人前の『ブッフ・ブルギニョン』が火の上で調理されているようにしたい、多くも少なくもない。」
  - `Health Check`を通じて、ヘッドシェフはすべてのストーブが正常かどうか常にパトロールします。欠陥のあるストーブのために1つが失敗した(`HC fail`)ことがわかった場合、すぐにそれを捨てて新しいストーブを起動し、アクティブなストーブの数が常に3であることを確保します。
  - **ロードバランシング:** ストーブが点火されると(新しいTaskが起動)、ヘッドシェフは自動的にフロントのウェイター(Application Load Balancer)に通知し、今追加の提供オープニングがあることを伝え、顧客の注文(トラフィック)を送ることができます。

**実装例**

```json
{
  "family": "app-service",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::account:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "app",
      "image": "your-registry/app:${ENVIRONMENT}",
      "portMappings": [
        {
          "containerPort": 3000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "${ENVIRONMENT}"
        }
      ],
      "secrets": [
        {
          "name": "DATABASE_URL",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:${ENVIRONMENT}/database-url"
        }
      ],
      "logConfiguration": {
```